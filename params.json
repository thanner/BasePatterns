{"name":"Base Patterns","tagline":"Trabalho de Laboratório de Engenharia de Software","body":"### Trabalho\r\nO trabalho em questão busca explicar e implementar os principais Base Patterns baseados no livro de Martin Fowler (Patterns of Enterprise Application). Os padrões presentes nesse projeto são: Gateway, Mapper, Layer Supertype, Separated Interface, Registry, Value Object, Money, Special Case, Plugin, Service Stub, Record Set.\r\n\r\n### Gateway\r\nUm objeto que encapsula o acesso a um sistema externo ou recurso.\r\n\r\nClasse Teste\r\n\r\n    public static void main(String[] args) {\r\n        Order order = new Order();\r\n        order.sendConfirmacao();\r\n    }\r\n\r\nClasse Order\r\n\r\n    private int valorTotal = 100;\r\n    public static final String SIMBOLO = \"R$\";\r\n    private String idOrder = \"10\";\r\n\r\n    public void sendConfirmacao() {\r\n        MenssageGateway msg = new MenssageGateway();\r\n        msg.sendConfirmacao(idOrder, valorTotal, SIMBOLO);\r\n    }\r\n\r\n\r\nClasse MenssageSender\r\n\r\n    public final static int PARAMETRO_NULO = -1;\r\n    public final static int TIPO_MENSAGEM_DESCONHECIDA = -2;\r\n    public final static int SUCESSO = 0;\r\n\r\n    public int send(String msg, Object[] args) {\r\n        return 0;\r\n    }\r\n\r\nClasse MenssageGateway\r\n\r\n    protected static final String CONFIRMACAO = \"CNFRM\";\r\n    private MenssageSender sender = new MenssageSender();\r\n\r\n    public void sendConfirmacao(String orderID, int amount,\r\n            String symbol) {\r\n        Object[] args = new Object[]{orderID, new Integer(amount),\r\n            symbol};\r\n        send(CONFIRMACAO, args);\r\n    }\r\n\r\n    private void send(String msg, Object[] args) {\r\n        int returnCode = doSend(msg, args);\r\n        if (returnCode == MenssageSender.PARAMETRO_NULO) {\r\n            throw new NullPointerException(\"Parametro null: \" + msg);\r\n        }\r\n        if (returnCode == MenssageSender.TIPO_MENSAGEM_DESCONHECIDA) {\r\n            throw new IllegalStateException(\r\n                    \"Inesperado erro do sistema de mensagem #:\" + returnCode);\r\n        }\r\n        if (returnCode == MenssageSender.SUCESSO) {\r\n            System.out.println(\"Sucesso\");\r\n        }\r\n    }\r\n\r\n    protected int doSend(String msg, Object[] args) {\r\n        assert (msg != null);\r\n        return sender.send(msg, args);\r\n    }\r\n\r\n### Mapper\r\nUm objeto que estabelece uma comunicação entre dois objetos independentes.\r\n\r\n### Layer Supertype\r\nUm tipo que atua como o supertipo para todos os tipos, na sua camada.\r\n\r\nClasse Teste\r\n\r\n    public static void main(String[] args) {\r\n        DomainObject domainExample = new DomainExample(Long.valueOf(\"2\"));\r\n        System.out.println(domainExample.getClass());\r\n    }\r\n\r\nClasse DomainObject\r\n\r\n    private Long ID;\r\n\r\n    public Long getID() {\r\n        return ID;\r\n    }\r\n\r\n    public void setID(Long ID) {\r\n        // assert.notNull(\"Cannot set a null ID\", ID);\r\n        this.ID = ID;\r\n    }\r\n\r\n    public DomainObject(Long ID) {\r\n        this.ID = ID;\r\n    }\r\n\r\n    public DomainObject() {\r\n\r\n    }\r\n\r\nClasse DomainExample (Extends DomainObject)\r\n\r\n    public DomainExample(Long ID) {\r\n        super(ID);\r\n    }\r\n\r\n### Separated Interface\r\nDefine uma interface em um pacote separado a partir de sua implementação.\r\n\r\nPacote Modelo - Interface UsuarioDAO\r\n\r\n    public static final UsuarioDAO INSTANCIA\r\n            = (UsuarioDAO) PluginFactory.getPlugin(UsuarioDAO.class);\r\n\r\n    public void insert(Usuario u) throws SQLException, IOException;\r\n\r\nPacote Modelo - Classe Usuario\r\n\r\n    private String login;\r\n    private String senha;\r\n\r\n    public void insereUsuario() throws SQLException, IOException {\r\n        if (login != null && senha != null) {\r\n            UsuarioDAO dao = new UsuarioDAOImpl();\r\n            dao.insert(this);\r\n        }\r\n    }\r\n\r\n    public void insereUsuarioComPlugin() throws SQLException, IOException {\r\n        if (login != null && senha != null) {\r\n            UsuarioDAO.INSTANCIA.insert(this);\r\n        }\r\n    }\r\n\r\n    public String getLogin() {\r\n        return login;\r\n    }\r\n\r\n    public String getSenha() {\r\n        return senha;\r\n    }\r\n\r\nPacote dao - Classe UsuarioDAOImpl (Implementa UsuarioDAO)\r\n\r\n    private Connection con;\r\n\r\n    public void setConnection(Connection con) {\r\n        this.con = con;\r\n    }\r\n\r\n    public void insert(Usuario u) throws SQLException {\r\n        PreparedStatement st = con.prepareStatement(\"INSERT INTO USUARIO (login, senha) values (?, ?)\");\r\n        st.setString(1, u.getLogin());\r\n        st.setString(2, u.getSenha());\r\n        st.executeUpdate();\r\n        st.close();\r\n    }\r\n\r\n### Registry\r\nUm objeto conhecido que outros objetos podem usar para encontrar objetos e serviços comuns.\r\n\r\nClasse RegistryStub\r\n\r\n    public RegistryStub() {\r\n        personFinderStub = new PersonFinderStub();\r\n    }\r\n\r\nClasse Registry\r\n\r\n    private static Registry getInstance() {\r\n        return soleInstance;\r\n    }\r\n    private static Registry soleInstance = new Registry();\r\n    protected PersonFinderStub personFinderStub = new PersonFinderStub();\r\n\r\n    public static PersonFinderStub personFinder() {\r\n        return getInstance().personFinderStub;\r\n    }\r\n\r\n    public static void initialize() {\r\n        soleInstance = new Registry();\r\n    }\r\n\r\n    public static void initializeStub() {\r\n        soleInstance = new RegistryStub();\r\n    }\r\n\r\nClasse PersonFinderStub\r\n\r\n    public Person find(long id) {\r\n        if (id == 1) {\r\n            return new Person(\"Soares\", \"Thanner\", 10);\r\n        }\r\n        throw new IllegalArgumentException(\"Con't find id: \" + String.valueOf(id));\r\n    }\r\n\r\nClasse Person\r\n\r\n    private String nome;\r\n    private String sobrenome;\r\n    private int i;\r\n\r\n    Person(String sobrenome, String nome, int i) {\r\n        this.nome = nome;\r\n        this.sobrenome = sobrenome;\r\n        this.i = i;\r\n    }\r\n\r\n    public String getNome() {\r\n        return nome;\r\n    }\r\n\r\n    public void setNome(String nome) {\r\n        this.nome = nome;\r\n    }\r\n\r\n    public String getSobrenome() {\r\n        return sobrenome;\r\n    }\r\n\r\n    public void setSobrenome(String sobrenome) {\r\n        this.sobrenome = sobrenome;\r\n    }\r\n\r\n    public int getI() {\r\n        return i;\r\n    }\r\n\r\n    public void setI(int i) {\r\n        this.i = i;\r\n    }\r\n\r\n### Value Object\r\nUm pequeno objeto simples, como dinheiro ou um intervalo de datas, cuja igualdade não é baseada em identidade.\r\n\r\nClasse Teste\r\n\r\n    public static void main(String[] args) {\r\n        Carro carro1 = new Carro();\r\n        carro1.setAno(\"1990\");\r\n        carro1.setCor(\"azul\");\r\n        Carro carro2 = new Carro(carro1);\r\n        System.out.println(carro1.equals(carro2));\r\n    }\r\n\r\nClasse Carro\r\n\r\n    private String cor;\r\n    private String ano;\r\n\r\n    Carro(Carro carro) {\r\n        this.cor = carro.getCor();\r\n        this.ano = carro.getAno();\r\n    }\r\n\r\n    Carro() {\r\n    }\r\n\r\n    public String getCor() {\r\n        return cor;\r\n    }\r\n\r\n    public void setCor(String cor) {\r\n        this.cor = cor;\r\n    }\r\n\r\n    public String getAno() {\r\n        return ano;\r\n    }\r\n\r\n    public void setAno(String ano) {\r\n        this.ano = ano;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        int hash = 3;\r\n        hash = 67 * hash + Objects.hashCode(this.cor);\r\n        hash = 67 * hash + Objects.hashCode(this.ano);\r\n        return hash;\r\n    }\r\n\r\n    @Override\r\n    public boolean equals(Object obj) {\r\n        return false;\r\n    }\r\n\r\n### Money\r\nRepresenta um valor monetário.\r\n\r\nClasse Teste\r\n\r\n    public static void main(String[] args) {\r\n\r\n        Money money = new Money(20.00, Currency.getInstance(Locale.US));\r\n        money = money.add(new Money(33.00, Currency.getInstance(Locale.US)));\r\n        System.out.println(money.toString());\r\n    }\r\n\r\nClasse Money\r\n\r\n    private long amount;\r\n    private Currency currency;\r\n    private int roundingMode;\r\n    private BigDecimal amountBig;\r\n    \r\n    public Money(){}\r\n    \r\n    public Money(double amount, Currency currency) {\r\n        this.currency = currency;\r\n        this.amount = Math.round(amount * centFactor());\r\n    }\r\n\r\n    public Money(long amount, Currency currency) {\r\n        this.currency = currency;\r\n        this.amount = amount * centFactor();\r\n    }\r\n    \r\n    public Money(BigDecimal amount, Currency currency, int roundingMode){\r\n        this.amountBig = amount;\r\n        this.currency = currency;\r\n        this.roundingMode = roundingMode;\r\n    }\r\n    \r\n    private static final int[] cents = new int[]{1, 10, 100, 1000};\r\n\r\n    private int centFactor() {\r\n        return cents[currency.getDefaultFractionDigits()];\r\n    }\r\n\r\n    public BigDecimal amount() {\r\n        return BigDecimal.valueOf(amount, currency.getDefaultFractionDigits());\r\n    }\r\n\r\n    public Currency currency() {\r\n        return currency;\r\n    }\r\n\r\n    public static Money dollars(double amount) {\r\n        return new Money(amount, Currency.getInstance(Locale.US));\r\n    }\r\n\r\n    public boolean equals(Object other) {\r\n        return (other instanceof Money) && equals((Money) other);\r\n    }\r\n\r\n    public boolean equals(Money other) {\r\n        return currency.equals(other.currency) && (amount == other.amount);\r\n    }\r\n\r\n    public int hashCode() {\r\n        return (int) (amount ^ (amount >>> 32));\r\n    }\r\n\r\n    public Money add(Money other) {\r\n        assertSameCurrencyAs(other);\r\n        return newMoney(amount + other.amount);\r\n    }\r\n\r\n    private void assertSameCurrencyAs(Money arg) {        \r\n        assertEquals(\"money math mismatch\", currency, arg.currency);\r\n    }\r\n\r\n    private Money newMoney(long amount) {\r\n        Money money = new Money();\r\n        money.currency = this.currency;\r\n        money.amount = amount;\r\n        return money;\r\n    }\r\n\r\n    public Money subtract(Money other) {\r\n        assertSameCurrencyAs(other);\r\n        return newMoney(amount - other.amount);\r\n    }\r\n\r\n    public int compareTo(Object other) {\r\n        return compareTo((Money) other);\r\n    }\r\n\r\n    public int compareTo(Money other) {\r\n        assertSameCurrencyAs(other);\r\n        if (amount < other.amount) {\r\n            return -1;\r\n        } else if (amount == other.amount) {\r\n            return 0;\r\n        } else {\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    public boolean greaterThan(Money other) {\r\n        return (compareTo(other) > 0);\r\n    }\r\n\r\n    public Money multiply(double amount) {\r\n        return multiply(new BigDecimal(amount));\r\n    }\r\n\r\n    public Money multiply(BigDecimal amount) {\r\n        return multiply(amount, BigDecimal.ROUND_HALF_EVEN);\r\n    }\r\n\r\n    public Money multiply(BigDecimal amount, int roundingMode) {\r\n        return new Money(amount().multiply(amount), currency, roundingMode);\r\n    }\r\n\r\n    public Money[] allocate(int n) {\r\n        Money lowResult = newMoney(amount / n);\r\n        Money highResult = newMoney(lowResult.amount + 1);\r\n        Money[] results = new Money[n];\r\n        int remainder = (int) amount % n;\r\n        for (int i = 0; i < remainder; i++) {\r\n            results[i] = highResult;\r\n        }\r\n        for (int i = remainder; i < n; i++) {\r\n            results[i] = lowResult;\r\n        }\r\n        return results;\r\n    }\r\n\r\n    public Money[] allocate(long[] ratios) {\r\n        long total = 0;\r\n        for (int i = 0; i < ratios.length; i++) {\r\n            total += ratios[i];\r\n        }\r\n        long remainder = amount;\r\n        Money[] results = new Money[ratios.length];\r\n        for (int i = 0; i < results.length; i++) {\r\n            results[i] = newMoney(amount * ratios[i] / total);\r\n            remainder -= results[i].amount;\r\n        }\r\n        for (int i = 0; i < remainder; i++) {\r\n            results[i].amount++;\r\n        }\r\n        return results;\r\n    }\r\n\r\n    public void testAllocate2() {\r\n        long[] allocation = {3, 7};\r\n        Money[] result = Money.dollars(0.05).allocate(allocation);\r\n        assertEquals(Money.dollars(0.02), result[0]);\r\n        assertEquals(Money.dollars(0.03), result[1]);\r\n    }\r\n    \r\n    public String toString(){\r\n        return this.amount + \" \" + this.currency.toString();\r\n    }\r\n\r\n### Special Case\r\nUma subclasse que fornece comportamento especial para casos particulares.\r\n\r\nClasse Teste\r\n\r\n    public static void main(String[] args) {\r\n        Employee employee = new NullEmployee();\r\n        System.out.println(employee.getName());\r\n    }\r\n\r\nClasse Employee\r\n\r\n    private String name;\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n\r\nClasse NullEmployee (Extends Employee)\r\n\r\n    public String getName() {\r\n        return \"Null Employee\";\r\n    }\r\n\r\n\r\n### Plugin\r\nLiga classes durante a configuração em vez de compilação.\r\n\r\nClasse UsuarioDAOImplArquivo (Implements UsuarioDAO)\r\n\r\n    public void insert(Usuario u) throws IOException {\r\n        File arquivo = new File(\"/home/jadson/temp/Usuario.txt\");\r\n        FileWriter writer = new FileWriter(arquivo, true);\r\n        PrintWriter saida = new PrintWriter(writer);\r\n        saida.println(\"<<\" + u.getClass().getSimpleName() + \">>\");\r\n        saida.println(u.getLogin() + \" - \" + u.getSenha());\r\n        saida.close();\r\n    }\r\n\r\nClasse PluginFactory\r\n\r\n    private static Properties props = new Properties();\r\n\r\n    static {\r\n        try {\r\n            props.load(PluginFactory.class.getResourceAsStream(\"/home/jadson/temp/plugins.properties\"));\r\n        } catch (Exception ex) {\r\n            throw new ExceptionInInitializerError(ex);\r\n        }\r\n    }\r\n\r\n    public static Object getPlugin(Class interfaceClass) {\r\n        String implName = props.getProperty(interfaceClass.getName());\r\n        if (implName == null) {\r\n            throw new RuntimeException(\"Implemenatacao nao exite: \"\r\n                    + interfaceClass.getName());\r\n        }\r\n        try {\r\n            return Class.forName(implName).newInstance();\r\n        } catch (Exception ex) {\r\n            throw new RuntimeException(\"Nao conseguiu criar uma \"\r\n                    + \" nova instancia: \"\r\n                    + interfaceClass.getName());\r\n        }\r\n    }\r\n\r\n### Service Stub\r\nRemove dependência de serviços problemáticos durante os testes.\r\n(Exemplo presente no Registry).\r\n\r\n### Record Set\r\nUma representação em memória de “dados tabulares”.\r\n\r\n### Autor\r\nThanner Soares Silva (@thanner).\r\n\r\n### Contato\r\nVocê pode estar entrando em contato com [Thanner Soares Silva](thannersoares@gmail.com) ou acessando a [Página do Github](https://github.com/thanner).","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}